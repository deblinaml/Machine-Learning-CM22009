<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Composing Networks in 2D — 3D Visualization</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=Source+Serif+4:ital,wght@0,400;0,600;1,400&display=swap');

  :root {
    --bg: #0e0e12;
    --panel: #16161c;
    --border: #2a2a35;
    --text: #e0ddd5;
    --muted: #8a8690;
    --accent: #5ce0d8;
    --accent2: #e85d3a;
    --accent3: #f0c040;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Source Serif 4', Georgia, serif;
    overflow-x: hidden;
    min-height: 100vh;
  }

  .header {
    text-align: center;
    padding: 28px 20px 8px;
  }

  .header h1 {
    font-family: 'JetBrains Mono', monospace;
    font-size: clamp(20px, 3vw, 32px);
    font-weight: 700;
    letter-spacing: -0.5px;
    background: linear-gradient(135deg, var(--accent), var(--accent3));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .header p {
    color: var(--muted);
    font-size: 14px;
    margin-top: 6px;
    font-style: italic;
  }

  .viz-container {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 4px;
    padding: 12px 16px;
    max-width: 1500px;
    margin: 0 auto;
  }

  .viz-panel {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 10px;
    overflow: hidden;
    position: relative;
  }

  .viz-panel canvas {
    display: block;
    width: 100%;
    height: 420px;
  }

  .panel-label {
    position: absolute;
    top: 10px;
    left: 12px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 13px;
    font-weight: 600;
    color: var(--accent);
    background: rgba(14,14,18,0.85);
    padding: 4px 10px;
    border-radius: 6px;
    border: 1px solid var(--border);
    z-index: 10;
    pointer-events: none;
  }

  .panel-sublabel {
    position: absolute;
    top: 38px;
    left: 12px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    color: var(--muted);
    background: rgba(14,14,18,0.85);
    padding: 3px 8px;
    border-radius: 5px;
    z-index: 10;
    pointer-events: none;
  }

  .controls {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 20px;
    padding: 14px 20px;
    flex-wrap: wrap;
  }

  .control-group {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .control-group label {
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .btn {
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    padding: 6px 14px;
    border: 1px solid var(--border);
    border-radius: 6px;
    background: var(--panel);
    color: var(--text);
    cursor: pointer;
    transition: all 0.2s;
  }

  .btn:hover { border-color: var(--accent); color: var(--accent); }
  .btn.active { background: var(--accent); color: var(--bg); border-color: var(--accent); }

  input[type="range"] {
    -webkit-appearance: none;
    width: 120px;
    height: 4px;
    background: var(--border);
    border-radius: 2px;
    outline: none;
  }

  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
  }

  .legend {
    display: flex;
    justify-content: center;
    gap: 28px;
    padding: 0 20px 14px;
    flex-wrap: wrap;
  }

  .legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    color: var(--muted);
  }

  .legend-swatch {
    width: 20px;
    height: 10px;
    border-radius: 2px;
  }

  .equation-bar {
    text-align: center;
    padding: 6px 20px 10px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 13px;
    color: var(--muted);
  }

  .equation-bar span { color: var(--accent); }

  .fold-lines-label {
    position: absolute;
    bottom: 10px;
    right: 12px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    color: var(--accent);
    background: rgba(14,14,18,0.85);
    padding: 3px 8px;
    border-radius: 5px;
    border: 1px solid rgba(92,224,216,0.2);
    z-index: 10;
    pointer-events: none;
    opacity: 0.8;
  }
</style>
</head>
<body>

<div class="header">
  <h1>Composing Networks in 2D</h1>
  <p>How stacking shallow networks creates complex decision boundaries through surface folding</p>
</div>

<div class="equation-bar">
  <span>x₁, x₂</span> → Network 1 → <span>y</span> → Network 2 → <span>y'</span>
</div>

<div class="viz-container">
  <div class="viz-panel">
    <div class="panel-label">① First Network Output: y</div>
    <div class="panel-sublabel">3 hidden units, ReLU</div>
    <div class="fold-lines-label">cyan = fold lines</div>
    <canvas id="canvas1"></canvas>
  </div>
  <div class="viz-panel">
    <div class="panel-label">② Second Network: y → y'</div>
    <div class="panel-sublabel">2 hidden units, ReLU</div>
    <canvas id="canvas2"></canvas>
  </div>
  <div class="viz-panel">
    <div class="panel-label">③ Composed Output: y'</div>
    <div class="panel-sublabel">More folds = more regions</div>
    <div class="fold-lines-label">cyan = fold lines</div>
    <canvas id="canvas3"></canvas>
  </div>
</div>

<div class="controls">
  <div class="control-group">
    <label>Rotate</label>
    <button class="btn active" id="btnAutoRotate" onclick="toggleAutoRotate()">Auto</button>
  </div>
  <div class="control-group">
    <label>Height Scale</label>
    <input type="range" id="heightScale" min="0.1" max="2.0" step="0.05" value="1.0" oninput="updateHeightScale(this.value)">
  </div>
  <div class="control-group">
    <label>Mesh</label>
    <button class="btn" id="btnWireframe" onclick="toggleWireframe()">Wireframe</button>
  </div>
  <div class="control-group">
    <label>Grid</label>
    <button class="btn active" id="btnGrid" onclick="toggleGrid()">Show</button>
  </div>
</div>

<div class="legend">
  <div class="legend-item">
    <div class="legend-swatch" style="background: linear-gradient(90deg, #1a0a04, #c24a18);"></div>
    Low output (negative)
  </div>
  <div class="legend-item">
    <div class="legend-swatch" style="background: linear-gradient(90deg, #c24a18, #f0c040);"></div>
    High output (positive)
  </div>
  <div class="legend-item">
    <div class="legend-swatch" style="background: var(--accent);"></div>
    Fold lines (ReLU boundaries)
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ============ Neural Network Functions ============

// Network 1: 2 inputs -> 3 hidden (ReLU) -> 1 output
// Mimics the surface in the original figure
const W1 = [
  [1.5, 1.0],   // h1
  [-1.0, 1.5],  // h2
  [1.0, -1.2],  // h3
];
const b1 = [0.1, -0.2, 0.3];
const w_out1 = [0.8, -0.6, 0.5];
const b_out1 = -0.1;

function relu(x) { return Math.max(0, x); }

function network1(x1, x2) {
  const h = [];
  for (let i = 0; i < 3; i++) {
    h.push(relu(W1[i][0] * x1 + W1[i][1] * x2 + b1[i]));
  }
  let y = b_out1;
  for (let i = 0; i < 3; i++) y += w_out1[i] * h[i];
  return y;
}

// Network 2: 1 input -> 2 hidden (ReLU) -> 1 output
// Creates a "tent" or fold shape like in the original figure panel c
const W2 = [1.2, -1.2];
const b2 = [0.3, 0.3];
const w_out2 = [1.0, 1.0];
const b_out2 = -0.3;

function network2(y) {
  const h1 = relu(W2[0] * y + b2[0]);
  const h2 = relu(W2[1] * y + b2[1]);
  return w_out2[0] * h1 + w_out2[1] * h2 + b_out2;
}

function composedNetwork(x1, x2) {
  return network2(network1(x1, x2));
}

// ============ Three.js Setup ============

const RES = 80;
let heightScale = 1.0;
let showWireframe = false;
let showGrid = true;
let autoRotate = true;

const scenes = [];
const cameras = [];
const renderers = [];
const meshes = [];
const wireframeMeshes = [];
const foldLineMeshes = [];
const gridHelpers = [];

function colorMap(val, minV, maxV) {
  let t = (val - minV) / (maxV - minV);
  t = Math.max(0, Math.min(1, t));
  // Dark brown -> burnt orange -> warm yellow
  const r = 0.1 + t * 0.84;
  const g = 0.04 + t * 0.7;
  const b = 0.02 + t * 0.22;
  return new THREE.Color(r, g, b);
}

function createSurface(canvasId, evalFn, index) {
  const canvas = document.getElementById(canvasId);
  const w = canvas.clientWidth || 480;
  const h = canvas.clientHeight || 420;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x16161c);

  const camera = new THREE.PerspectiveCamera(40, w / h, 0.1, 100);
  camera.position.set(3.2, 2.8, 3.2);
  camera.lookAt(0, 0, 0);

  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setSize(w, h);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

  // Lights
  const ambient = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambient);
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
  dirLight.position.set(3, 5, 3);
  scene.add(dirLight);
  const dirLight2 = new THREE.DirectionalLight(0x5ce0d8, 0.2);
  dirLight2.position.set(-3, 2, -2);
  scene.add(dirLight2);

  // Evaluate function over grid
  const values = [];
  let minV = Infinity, maxV = -Infinity;

  for (let j = 0; j <= RES; j++) {
    for (let i = 0; i <= RES; i++) {
      const x1 = -1 + (2 * i / RES);
      const x2 = -1 + (2 * j / RES);
      let v;
      if (index === 1) {
        // For network2, show it as 2D curve extruded
        v = network2(x1); // x1 is the y-input axis
      } else {
        v = evalFn(x1, x2);
      }
      values.push(v);
      if (v < minV) minV = v;
      if (v > maxV) maxV = v;
    }
  }

  // Build geometry
  const geo = new THREE.BufferGeometry();
  const positions = [];
  const colors = [];
  const indices = [];

  for (let j = 0; j <= RES; j++) {
    for (let i = 0; i <= RES; i++) {
      const x = -1 + (2 * i / RES);
      const z = -1 + (2 * j / RES);
      const v = values[j * (RES + 1) + i];
      const yPos = ((v - minV) / (maxV - minV) - 0.5) * 2 * heightScale;

      positions.push(x, yPos, z);
      const col = colorMap(v, minV, maxV);
      colors.push(col.r, col.g, col.b);
    }
  }

  for (let j = 0; j < RES; j++) {
    for (let i = 0; i < RES; i++) {
      const a = j * (RES + 1) + i;
      const b = a + 1;
      const c = a + (RES + 1);
      const d = c + 1;
      indices.push(a, b, d, a, d, c);
    }
  }

  geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
  geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
  geo.setIndex(indices);
  geo.computeVertexNormals();

  const mat = new THREE.MeshPhongMaterial({
    vertexColors: true,
    side: THREE.DoubleSide,
    shininess: 30,
  });

  const mesh = new THREE.Mesh(geo, mat);
  scene.add(mesh);

  // Wireframe overlay
  const wireMat = new THREE.MeshBasicMaterial({
    color: 0x000000,
    wireframe: true,
    transparent: true,
    opacity: 0.08,
  });
  const wireMesh = new THREE.Mesh(geo, wireMat);
  wireMesh.visible = showWireframe;
  scene.add(wireMesh);

  // Grid helper at y = -1
  const grid = new THREE.GridHelper(2, 10, 0x2a2a35, 0x1f1f28);
  grid.position.y = -1;
  grid.visible = showGrid;
  scene.add(grid);

  // Axes
  const axesMat = new THREE.LineBasicMaterial({ color: 0x4a4a55 });
  // X axis
  const xGeo = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(-1, -1, -1),
    new THREE.Vector3(1, -1, -1)
  ]);
  scene.add(new THREE.Line(xGeo, axesMat));
  // Z axis
  const zGeo = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(-1, -1, -1),
    new THREE.Vector3(-1, -1, 1)
  ]);
  scene.add(new THREE.Line(zGeo, axesMat));
  // Y axis
  const yGeo = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(-1, -1, -1),
    new THREE.Vector3(-1, 1, -1)
  ]);
  scene.add(new THREE.Line(yGeo, axesMat));

  // Find and draw fold lines (where ReLU activations change)
  if (index !== 1) {
    const foldGroup = new THREE.Group();
    drawFoldLines(foldGroup, evalFn, index, minV, maxV);
    scene.add(foldGroup);
    foldLineMeshes.push(foldGroup);
  } else {
    foldLineMeshes.push(null);
  }

  scenes.push(scene);
  cameras.push(camera);
  renderers.push(renderer);
  meshes.push({ mesh, geo, evalFn, index, minV, maxV });
  wireframeMeshes.push(wireMesh);
  gridHelpers.push(grid);

  return { scene, camera, renderer };
}

function drawFoldLines(group, evalFn, index, minV, maxV) {
  // For network1, fold lines are where w·x + b = 0 for each hidden unit
  // For composed, fold lines come from both networks
  const foldMat = new THREE.LineBasicMaterial({ color: 0x5ce0d8, linewidth: 2, transparent: true, opacity: 0.9 });

  if (index === 0) {
    // Network 1 fold lines: W1[i][0]*x1 + W1[i][1]*x2 + b1[i] = 0
    for (let i = 0; i < 3; i++) {
      const points = [];
      for (let t = -1; t <= 1; t += 0.01) {
        let x1, x2;
        if (Math.abs(W1[i][1]) > 0.01) {
          x1 = t;
          x2 = -(W1[i][0] * x1 + b1[i]) / W1[i][1];
        } else {
          x2 = t;
          x1 = -(W1[i][1] * x2 + b1[i]) / W1[i][0];
        }
        if (x1 >= -1 && x1 <= 1 && x2 >= -1 && x2 <= 1) {
          const v = evalFn(x1, x2);
          const yPos = ((v - minV) / (maxV - minV) - 0.5) * 2 * heightScale + 0.01;
          points.push(new THREE.Vector3(x1, yPos, x2));
        }
      }
      if (points.length > 1) {
        const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
        group.add(new THREE.Line(lineGeo, foldMat));
      }
    }
  } else if (index === 2) {
    // Composed network has fold lines from network1 AND from network2
    // Network1 folds
    for (let i = 0; i < 3; i++) {
      const points = [];
      for (let t = -1; t <= 1; t += 0.01) {
        let x1, x2;
        if (Math.abs(W1[i][1]) > 0.01) {
          x1 = t;
          x2 = -(W1[i][0] * x1 + b1[i]) / W1[i][1];
        } else {
          x2 = t;
          x1 = -(W1[i][1] * x2 + b1[i]) / W1[i][0];
        }
        if (x1 >= -1 && x1 <= 1 && x2 >= -1 && x2 <= 1) {
          const v = evalFn(x1, x2);
          const yPos = ((v - minV) / (maxV - minV) - 0.5) * 2 * heightScale + 0.01;
          points.push(new THREE.Vector3(x1, yPos, x2));
        }
      }
      if (points.length > 1) {
        const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
        group.add(new THREE.Line(lineGeo, foldMat));
      }
    }

    // Network2 folds: where y (output of net1) hits the kinks of net2
    // Network2 kinks at W2[k]*y + b2[k] = 0 => y = -b2[k]/W2[k]
    for (let k = 0; k < 2; k++) {
      const yThresh = -b2[k] / W2[k];
      // Find contour where network1(x1,x2) = yThresh
      const points = [];
      for (let j = 0; j < RES; j++) {
        for (let i = 0; i < RES; i++) {
          const x1a = -1 + (2 * i / RES);
          const x2a = -1 + (2 * j / RES);
          const x1b = -1 + (2 * (i + 1) / RES);
          const x2b = -1 + (2 * (j + 1) / RES);

          // Check edges of this grid cell
          const corners = [
            { x1: x1a, x2: x2a, v: network1(x1a, x2a) },
            { x1: x1b, x2: x2a, v: network1(x1b, x2a) },
            { x1: x1b, x2: x2b, v: network1(x1b, x2b) },
            { x1: x1a, x2: x2b, v: network1(x1a, x2b) },
          ];

          for (let e = 0; e < 4; e++) {
            const c0 = corners[e];
            const c1 = corners[(e + 1) % 4];
            if ((c0.v - yThresh) * (c1.v - yThresh) < 0) {
              const t2 = (yThresh - c0.v) / (c1.v - c0.v);
              const px1 = c0.x1 + t2 * (c1.x1 - c0.x1);
              const px2 = c0.x2 + t2 * (c1.x2 - c0.x2);
              const v = evalFn(px1, px2);
              const yPos = ((v - minV) / (maxV - minV) - 0.5) * 2 * heightScale + 0.01;
              points.push(new THREE.Vector3(px1, yPos, px2));
            }
          }
        }
      }
      // Sort points roughly for line drawing
      if (points.length > 1) {
        // Simple nearest-neighbor sort
        const sorted = [points.shift()];
        while (points.length > 0) {
          const last = sorted[sorted.length - 1];
          let bestIdx = 0;
          let bestDist = Infinity;
          for (let p = 0; p < points.length; p++) {
            const d = last.distanceTo(points[p]);
            if (d < bestDist) { bestDist = d; bestIdx = p; }
          }
          if (bestDist > 0.15) {
            // Start new segment
            const lineGeo = new THREE.BufferGeometry().setFromPoints(sorted.slice());
            group.add(new THREE.Line(lineGeo, foldMat));
            sorted.length = 0;
          }
          sorted.push(points.splice(bestIdx, 1)[0]);
        }
        if (sorted.length > 1) {
          const lineGeo = new THREE.BufferGeometry().setFromPoints(sorted);
          group.add(new THREE.Line(lineGeo, foldMat));
        }
      }
    }
  }
}

function rebuildSurface(info) {
  const { mesh, geo, evalFn, index, minV, maxV } = info;
  const posAttr = geo.getAttribute('position');
  const colAttr = geo.getAttribute('color');

  for (let j = 0; j <= RES; j++) {
    for (let i = 0; i <= RES; i++) {
      const idx = j * (RES + 1) + i;
      const x = -1 + (2 * i / RES);
      const z = -1 + (2 * j / RES);
      let v;
      if (index === 1) {
        v = network2(x);
      } else {
        v = evalFn(x, z);
      }
      const yPos = ((v - minV) / (maxV - minV) - 0.5) * 2 * heightScale;
      posAttr.setY(idx, yPos);
    }
  }

  posAttr.needsUpdate = true;
  geo.computeVertexNormals();
}

// Initialize
createSurface('canvas1', network1, 0);
createSurface('canvas2', network2, 1);
createSurface('canvas3', composedNetwork, 2);

// ============ Mouse Interaction ============

let isDragging = false;
let prevMouse = { x: 0, y: 0 };
let rotationY = 0.6;
let rotationX = 0.5;
let autoRotateAngle = 0;

document.addEventListener('mousedown', (e) => {
  if (e.target.tagName === 'CANVAS') {
    isDragging = true;
    prevMouse = { x: e.clientX, y: e.clientY };
    autoRotate = false;
    document.getElementById('btnAutoRotate').classList.remove('active');
  }
});

document.addEventListener('mousemove', (e) => {
  if (!isDragging) return;
  const dx = (e.clientX - prevMouse.x) * 0.005;
  const dy = (e.clientY - prevMouse.y) * 0.005;
  rotationY += dx;
  rotationX = Math.max(-1, Math.min(1.2, rotationX + dy));
  prevMouse = { x: e.clientX, y: e.clientY };
});

document.addEventListener('mouseup', () => { isDragging = false; });

// Touch support
document.addEventListener('touchstart', (e) => {
  if (e.target.tagName === 'CANVAS') {
    isDragging = true;
    prevMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    autoRotate = false;
    document.getElementById('btnAutoRotate').classList.remove('active');
  }
});

document.addEventListener('touchmove', (e) => {
  if (!isDragging) return;
  const dx = (e.touches[0].clientX - prevMouse.x) * 0.005;
  const dy = (e.touches[0].clientY - prevMouse.y) * 0.005;
  rotationY += dx;
  rotationX = Math.max(-1, Math.min(1.2, rotationX + dy));
  prevMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
});

document.addEventListener('touchend', () => { isDragging = false; });

// ============ Controls ============

function toggleAutoRotate() {
  autoRotate = !autoRotate;
  document.getElementById('btnAutoRotate').classList.toggle('active', autoRotate);
}

function updateHeightScale(val) {
  heightScale = parseFloat(val);
  meshes.forEach(info => rebuildSurface(info));
  // Rebuild fold lines too
  foldLineMeshes.forEach((group, i) => {
    if (!group) return;
    const scene = scenes[i];
    scene.remove(group);
    const newGroup = new THREE.Group();
    drawFoldLines(newGroup, meshes[i].evalFn, meshes[i].index, meshes[i].minV, meshes[i].maxV);
    scene.add(newGroup);
    foldLineMeshes[i] = newGroup;
  });
}

function toggleWireframe() {
  showWireframe = !showWireframe;
  document.getElementById('btnWireframe').classList.toggle('active', showWireframe);
  wireframeMeshes.forEach(m => { m.visible = showWireframe; });
}

function toggleGrid() {
  showGrid = !showGrid;
  document.getElementById('btnGrid').classList.toggle('active', showGrid);
  gridHelpers.forEach(g => { g.visible = showGrid; });
}

// ============ Animation Loop ============

function animate() {
  requestAnimationFrame(animate);

  if (autoRotate) {
    autoRotateAngle += 0.003;
    rotationY = autoRotateAngle;
  }

  const dist = 4.0;
  const cx = dist * Math.sin(rotationY) * Math.cos(rotationX);
  const cy = dist * Math.sin(rotationX) + 0.5;
  const cz = dist * Math.cos(rotationY) * Math.cos(rotationX);

  cameras.forEach(cam => {
    cam.position.set(cx, cy, cz);
    cam.lookAt(0, 0, 0);
  });

  renderers.forEach((r, i) => {
    r.render(scenes[i], cameras[i]);
  });
}

animate();

// Handle resize
window.addEventListener('resize', () => {
  renderers.forEach((r, i) => {
    const canvas = r.domElement;
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    r.setSize(w, h);
    cameras[i].aspect = w / h;
    cameras[i].updateProjectionMatrix();
  });
});
</script>

</body>
</html>
